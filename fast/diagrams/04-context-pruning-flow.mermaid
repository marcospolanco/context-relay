sequenceDiagram
    participant Optimizer as System Optimizer
    participant Frontend as Frontend Client
    participant API as FastAPI Server
    participant Logic as Logic Layer
    participant DB as MongoDB
    participant Embedding as Embedding Service
    participant SSE as SSE Broadcaster
    participant Clients as SSE Clients

    Note over Optimizer,Clients: Context Pruning Operations

    Optimizer->>Frontend: initiate_pruning(context_id, strategy, budget)
    Note right of Optimizer: {context_id: "ctx-large", pruning_strategy: "recency", budget: 50}

    Frontend->>API: POST /context/prune
    Note right of Frontend: {context_id: "ctx-large", pruning_strategy: "recency", budget: 50}

    API->>Logic: validate_prune_request(request)
    Logic->>Logic: validate_context_id()
    Logic->>Logic: validate_pruning_strategy()
    Logic->>Logic: validate_budget()

    API->>DB: fetch_context(context_id)
    DB-->>API: existing_context_packet
    Note right of DB: Context with 100 fragments

    alt Context Found
        Logic->>Logic: check_current_fragment_count()

        alt Current Count > Budget
            Logic->>Logic: select_pruning_strategy()

            alt Recency Strategy
                Logic->>Logic: sort_fragments_by_timestamp()
                Note right of Logic: Most recent fragments first
                Logic->>Logic: keep_top_n_fragments(budget)
                Logic->>Logic: create_removal_trace("recency", removed_fragments)

            else Semantic Diversity Strategy
                Logic->>Logic: cluster_similar_fragments()

                loop For Each Fragment Cluster
                    Logic->>Embedding: compute_similarity_within_cluster()
                    Embedding-->>Logic: similarity_scores
                end

                Logic->>Logic: select_diverse_representatives()
                Note right of Logic: Keep one fragment per semantic cluster
                Logic->>Logic: create_diversity_trace(clusters, selected_fragments)

            else Importance Strategy
                Logic->>Logic: sort_fragments_by_importance()
                Note right of Logic: Highest importance scores first
                Logic->>Logic: protect_high_importance_fragments()
                Note right of Logic: Keep fragments with importance > 0.8
                Logic->>Logic: fill_remaining_budget()
                Logic->>Logic: create_importance_trace(importance_decisions)
            end

            Logic->>Logic: build_pruned_context_packet()
            Note right of Logic: {context_id, pruned_fragments[], decision_trace[], pruning_metadata}

            Logic->>DB: store_pruned_context(pruned_context)
            DB-->>Logic: confirmation

            Logic->>SSE: broadcast_event("contextPruned", prune_payload)
            Note right of SSE: {context_id, pruned_context}

            SSE->>Clients: event: contextPruned
            SSE->>Clients: data: {...}

            Logic-->>API: PruneResponse
            Note right of Logic: {pruned_context}

            API-->>Frontend: HTTP 200 + response

        else Current Count <= Budget
            Logic->>SSE: broadcast_event("error", no_prune_payload)
            Note right of SSE: {error_code: "BUDGET_EXCEEDS_SIZE", message}

            Logic-->>API: error_response
            API-->>Frontend: HTTP 400 + error_message
        end

    else Context Not Found
        Logic->>SSE: broadcast_event("error", not_found_payload)
        Note right of SSE: {error_code: "CONTEXT_NOT_FOUND", message}

        Logic-->>API: error_response
        API-->>Frontend: HTTP 404 + error
    end

    alt Embedding Service Unavailable (for Semantic Strategy)
        Note over Logic: Semantic pruning requires embedding service
        Logic->>SSE: broadcast_event("error", service_unavailable_payload)
        Note right of SSE: {error_code: "EMBEDDING_SERVICE_UNAVAILABLE", message}

        Logic-->>API: error_response
        API-->>Frontend: HTTP 503 + error
    end

    Note over Optimizer,Clients: Pruning operation complete